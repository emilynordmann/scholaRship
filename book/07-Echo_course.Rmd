# Exploring Echo360 video/course level data in R with `tidyverse` {#Echo_course}

## Introduction

Now we have introduced you to the basic principles of reading and summarising Echo360 data, in this chapter we will explore how you can wrangle and visualise video and course level data to recreate and build on the kind of dashboards you can access on Echo360. 

You will need the following packages which are the same as chapter 6, but with the addition of `scales` to add some useful functions for plotting graph axes. You will also need the `data` object you created in chapter 6, but you can rerun the code below if you do not have it available already. If you do not have the data downloaded already, please [download the .zip file](data/Echo360_Data/Echo360_data.zip) containing 9 files of Echo360 data. Our tutorial assumes you have a folder called "data" in your working directory, and we created a subfolder called "Echo360_Data" to place these files. If you saved the data in another way, remember to edit the file paths first. 

```{r, warning=FALSE, message=FALSE}
library(tidyverse) # Package of packages for plotting and wrangling 
library(plotly) # Creates interactive plots 
library(ggpubr) # Builds on ggplot2 to build specific publication ready plots 
library(scales) # Includes functions for specifying plot scales
library(lubridate)
```

```{r load objects from chapter 6, message=FALSE, warning=FALSE}
# Obtain list of files from directory
files <- list.files(path = "data/Echo360_Data/", 
                    pattern=".csv") 

# Read in all files
data <- read_csv(paste0("data/Echo360_Data/", files), # Add our working directory to the list of files 
                 id="video") # What should be call the column containing the name of the video file? 

# Fill in spaces between column names
data <- tibble(data, 
               .name_repair = "universal") # Setting to universal makes all names unique and syntactic

# To break this code down, we start with the innermost function
# 1. We first make each unique video name a factor (unique category)
# 2. We then make each factor a number, so we get an ascending number from 1 to 9
data$video <- as.numeric(as.factor(data$video))
```

## Handling date/time data with `lubridate`

Handling date/time data in R is somewhat different from other variable types and should be treated differently and handled with care. The `lubridate` package in R (loaded as part of the `tidyverse`) allows us to easily handle tricky date/time data and extract useful information from these. 

### Converting variables to date/time format

The first task will be to convert any date/time data we have into the correct format. In the sample data we are working with, we have five variables which contain such data which are: `Create.Date`, `Duration`, `Total.View.Time`, `Average.View.Time` and `Last.Viewed`. 

On closer inspection, these variables fall into two types:

- `Create.Data` and `Last.Viewed` are listed as a date (a particular day)

- `Duration`, `Total.View.Time` and `Average.View.Time` are listed as a time, recorded in hours, minutes, and seconds.

Several functions can be used to take a data string and convert it into the desired date/time format. There is a useful [cheat sheet you can download](https://rstudio.github.io/cheatsheets/html/lubridate.html) for the `lubridate` library which contains examples of such functions. For our data, we will use the `mdy()` function to convert dates as month-day-year, and the `hms()` function to convert times as hours-minutes-seconds.

```{r recode data as hms and mdy}
# For times, mutate across three columns and convert to hours, minutes, seconds
# For dates, mutate across two columns and convert to month, day, year
data <- data %>%
  mutate(across(.cols = c('duration', 'total_view_time', 'average_view_time'), 
                .fns = hms)) %>%
  mutate(across(.cols = c('create_date', 'last_viewed'), 
                .fns = mdy))
```

Here, we use a combination of mutate and across to apply a given function to multiple columns. Within across, we specify two arguments. In .cols, we specify the columns we want to apply our function to and in .fns, we specify the function we want to apply to those columns.

::: {.info data-latex=""}
`hms()` converts a string into a date/time object which is set by hours-minutes-seconds. `mdy()` converts a string into a date/time object which is set by month-day-year. Echo360 data saves date/times in US format, so pay attention to how date/time data is stored to data you work with to make sure it recognises the information in the right order. There are alternative functions like `ymd()` and `dmy()` if data you work with is stored differently. 
:::

We can take a look at the result of these transformations more closely using `head()` to preview the first five cases of each variable:

```{r preview time and date data}
# First five cases of duration 
head(data$duration)
# First five cases of last viewed
head(data$last_viewed)
```

### Extracting elements from date/time data

Sometimes, you may wish to obtain specific parts of a date/time such as the month, the minutes etc. There are several functions in `lubridate` which allow us to extract these easily from a date/time object.

Say we wish to only obtain the minutes from `Average.View.Time`, we can obtain this easily using the `r hl(minute())` function and preview the first five cases. 

```{r isolate minutes}
# Add a new average view minutes column to our data
data <- data %>% 
  mutate(average_view_minute = minute(data$average_view_time)) # Isolate the minutes from the average view time column

# Print the first five cases
head(data$average_view_minute)
```

As we start to get into the habit of visualising data to aid exploration, we can quickly observe some summary statistics by producing a boxplot of the average view time in minutes. 

```{r average minute boxplot}
fig_avg_minutes <- data %>% 
  ggplot(aes(y = average_view_minute)) + # We only need the y axis of view time minutes
  geom_boxplot() + # Add a boxplot layer
  labs(title = "Boxplot of average video viewing times",
       y = "View time (mins)") + # Specify the main title and y axis label
  theme_bw() # Tidy up the theme

fig_avg_minutes
```

Sometimes it can be difficult to precisely identify the y axis value for each element in a plot, so you can also produce an interactive version of the boxplot by using the `r pkg("plotly")` package. Once we define a graph in `ggplot2`, we can convert it into an interactive plot using the `ggplotly()` function. 

```{r plotly avg minutes}
ggplotly(fig_avg_minutes)
```

As a further example using a date variable, suppose we want to look at the last month students viewed videos across the course. We can obtain this by applying the `r hl(month())` function to the `Last.Viewed` variable.

```{r last month viewed bar chart}
# Add a new month column 
data <- data %>% 
  mutate(month_last_viewed = month(data$last_viewed))

last_viewed <- data %>% 
  ggplot(aes(x = month_last_viewed)) + # Only specify x axis for a bar chart
  geom_bar() + # Create a bar chart 
  labs(title = "Frequency of last month video viewed",
       y = "Frequency",
       x = "Last month video viewed") + 
  theme_bw() + 
  scale_x_continuous(breaks = breaks_pretty()) # Function to tidy up the x axis breaks specifically for dates

last_viewed
```

As above, we can convert the bar chart to make it interactive using the `r hl(ggplotly())` function. This allows you to hover over the plot and see what the frequency was for each month. 

```{r plotly last viewed}
ggplotly(last_viewed)
```

### Maths with date-times

Sometimes, we may wish to compare the difference in time between certain events. Again, `lubridate` provides some useful functions to help us with this. For example, we can look at the difference in average view time to total view time by for a certain video by using simple arithmetic operators

```{r}
data_video1 <- data[data$video==1, ]

data_video1 <- data_video1 %>% 
  mutate(time_difference=average_view_time-duration)

head(data_video1$time_difference)
```

As this data returns values in minutes and seconds, we will have to transform this to one unit type to visualise

```{r}
data_video1$time_difference <- second(data_video1$time_difference)

time_difference <- ggplot(data_video1, aes(y=time_difference)) + 
  geom_boxplot() + 
  labs(title="Boxplot of average video viewing times compared to total times") + 
  ylab("View time (seconds)") + 
  theme_bw() + 
  geom_hline(yintercept=0,color="red")

time_difference
```

```{r}
ggplotly(time_difference)
```

## Total views for each video
In the following sections we will mostly be creating plots of our data summarised at video level. Given that our data is currently stored at student level (one row per student per video) we will transform our data into a new data set called `video_data` which will group the data by video and create some variables of interest. Firstly, let's create this new data set with two columns:

* `Video`: The video number stored as a factor (this will make it easier to plot later on);

* `Total_Views`: The total number of views per video.

```{r}
video_data <- data %>% group_by(ideo) %>%
  summarise(total_views=sum(total_views)) %>%
  mutate_at('video', factor)
```

We can now easily create a bar chart of the total number of views per video as follows:

```{r}
fig.total.views <- ggplot(video_data, aes(x=video, y=total_views)) +
  geom_bar(stat = "identity") + 
  labs(title="Total number of views per video") + 
  ylab("Total views") +
  xlab("Video") +
  theme_bw()

fig.total.views
```

Here we plot the video number along the x-axis and the total number of views for each video on the y-axis. These numbers include duplications from students who have watched the videos multiple times. We may also be interested in the total number of unique views, i.e. the total number of students who watched the video at least once. To do this, we need to create a new variable called `unique_views` which will contain the sum of the rows for each video. We can add this to the video-level data set `video_data`.

```{r}
video_data <- data %>% group_by(video) %>%
  summarise(Total_Views=sum(total_views), unique_views=n()) %>%
  mutate_at('video', factor)
```

We can edit the code for the previous bar chart to create a bar chart of the total number of unique student views per video as follows:

```{r}
fig.unique.views<-ggplot(video_data, aes(x=video, y=unique_views)) +
  geom_bar(stat = "identity") + 
  labs(title="Total number of unique student views per video") + 
  ylab("Unique student views") +
  xlab("Video") +
  theme_bw()

fig.unique.views
```

### Creating an interactive version using `plotly`.

We can create more interactive plots, allowing us to share information on our data in a more interactive environment using `plotly`. 

Let's start by creating a `plotly` version of the barchart of unique student views using the following the `ggplotly()` function.

```{r}
ggplotly(fig.unique.views)

```

**Advanced**

We can add additional information such as total views, duration of video and average view time into the hover text as follows.

```{r}
video_data <- data %>%
  group_by(video) %>%
  summarise(total_views=sum(total_views), video_data=n(), average_view_time=mean(period_to_seconds(average_view_time), na.rm=T)) %>%
  mutate(average_view_time=round(seconds_to_period(average_view_time),0),
         repeated_views=total_views-video_data,
         duration = hms(c('00:10:48', '00:13:11', '00:13:55', '00:14:11', '00:14:42', '00:15:08', '00:16:20', '00:16:34', '00:18:28')),
         percentage_viewed=average_view_time/duration*100)

fig.all.views <- plot_ly(video_data,
  x = ~as.factor(video),
  y = ~video_data,
  name = "Unique Views",
  type = "bar",
  hovertemplate = paste0("Video %{x}",
                         "<br>Total views:", video_data$total_views,
                         "<br>Unique views: %{y}",
                         "<br> Duration: ", video_data$duration,
                         "<br> Average view time: ", video_data$average_view_time,
                         "<extra></extra>")

)%>%
  layout(title = 'Video views', xaxis = list(title = 'Video number'),
         yaxis = list(title = 'Unique views'))

fig.all.views
```

We might also want to create a stacked barchart with the total number of views split into unique student views and repeated views. We can do this in `plotly` as follows.

```{r}
fig.all.views <- fig.all.views %>% 
  add_trace(y = ~repeated_views, name = 'Repeated views')

fig.all.views <- fig.all.views %>% 
  layout(yaxis = list(title = 'Count'), barmode = 'stack')

fig.all.views
```

## Video duration vs. average percentage viewed

We will now create a scatterplot of video duration vs. the average percentage of video viewed using `ggplot` as follows.

```{r}
fig.duration.viewed <- ggplot(video_data, aes(x=as.numeric(duration, 'minutes'), y=percentage_viewed)) +
  geom_point()+ 
  labs(title="Video duration vs. average percentage viewed") + 
  ylab("Average percentage of video viewed") +
  xlab("Video duration") +
  theme_bw()

fig.duration.viewed
```

```{r}
ggplotly(fig.duration.viewed)
```

**Advanced**

We can add additional information such as video number average view time into the hover text as follows.

```{r}
fig.duration.viewed.2 <- plot_ly(video_data,
               x = ~as.numeric(duration, 'minutes'),
               y = ~percentage_viewed,
               type = "scatter",
               mode = "markers",
               hovertemplate = paste0("Video ", video_data$video,
                                      "<br>Average percentage viewed: ", round(video_data$percentage_viewed,1), "%",
                                      "<br> Duration: ", video_data$duration,
                                      "<br> Average view time: ", video_data$average_view_time,
                                      "<extra></extra>"))%>%
  layout(xaxis = list(title = 'Duration of video'),
         yaxis = list(title = 'Percentage of video viewed'))

fig.duration.viewed.2
```

